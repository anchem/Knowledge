# 面向对象分析与设计

## 1. 概念

### 1.1. 复杂性

软件危机很大程度上是由于复杂度管理失控导致的。

复杂性是软件的固有属性。

观察自然界的复杂系统：

```
复杂系统是层次化的，不同层次代表不同的抽象级别。
复杂系统的各部件可以分解为独立的部件，以便独立地研究。

同一层抽象中的所有部分之间以某种定义良好的方式进行交互。
在给定层的内外之间总有清晰的边界。
```

造成固有复杂性的原因：

1. 问题域的复杂性。需求定义不准确、数量多、关系复杂、经常变化。“在我们修整错误时，这是维护；在我们应对改变的需求时，这是演化；当我们使用一些极端的手段来保持古老而陈腐的软件继续工作时，这是保护。”
2. 管理开发过程的困难性。难点在于维持设计的一致性和完整性。
3. 软件中随处可见的灵活性。开发者可以表达任何形式的抽象，尤其是初级模块的构建，这样缺少了标准和规范。劳动密集型。
4. 描述离散系统行为的问题。系统中的变量构成了系统的离散状态，而状态与状态之间的转换关系并非总是确定的。

良好复杂系统的5个属性：

1. 层次结构。复杂性常常以层次结构的形式存在。复杂的系统由一些相关的子系统组成，这些子系统又有自己的系统，如此下去，直到达到某种最低层次的基本构件。
2. 相对本原。选择哪些作为系统的基础组件相对来说比较随意，这在很大程度上取决于系统观察者的判断。
3. 分离关注。组件内的联系通常比组件间的联系更强。这一事实将组件中高频率的动作（涉及组件的内部结构）和低频率的动作（涉及组件间的相互作用）分离开来。这样我们可以以相对隔离的方式来研究每个部分。
4. 共同模式。层次结构通常只是由少数不同类型的子系统按照不同的组合和安排方式构成的。涉及小组件的复用。
5. 稳定的中间形式。复杂系统都是从能工作的简单系统演变而来的。如果存在稳定的中间形式，从简单系统到复杂系统的演变将更快。随着系统的演变，曾经被认为是复杂的对象就变成了基础对象，在这些对象的基础上构建更复杂的系统。

复杂系统的层次结构的规范形式：

类结构：按照结构上的组成部分（part of）进行分解。

对象结构：共同特性的抽象与具体对象，代表了是一种（is a）的层次结构。基础类和抽象类

模块结构*：描述了系统物理组件之间的关系。

处理层次结构*：描述了系统的动态组件之间的关系。

良好的软件系统应当包含深思熟虑的类结构和对象结构，并具备复杂系统的5个属性。

难题：要开发的软件系统的复杂性在增加，而我们处理复杂性的能力有限。

控制复杂性的方法：

【分解】

算法分解：自顶向下结构化地分解，通过算法分解将大问题分解为较小的步骤。强调事件的顺序。

数据驱动：系统输入和输出之间的映射关系驱动着软件系统的结构。

面向对象分解：根据问题领域中的关键抽象概念进行分解。把世界看成是一组自动化的代理，它们相互协作，执行某种高级行为。强调了一些代理，它们要么发出动作，要么是这些操作执行的对象。

【抽象】

不能够全面掌握一个复杂的对象，我们就选择忽略它的非本质的细节，转而处理这个对象的一般化、理想化的模型。

【层次结构】

在复杂的软件系统中显式地组织类和对象层次结构。

对象结构展示了不同的对象之间如何通过一些交互模式进行协作。

类结构强调了系统中的公共结构行为。

复杂系统的设计既包括想象力的跳跃，也包括经验和知识的融合，是科学和艺术的工程。

设计的目的是要构建如下的一个系统：

- 满足给定的（可能是非正式的）功能规格说明；
- 符合目标介质的限制；
- 满足隐含的和明确的性能及资源使用需求；
- 满足隐含的和明确的关于产品形式方面的设计限制条件；
- 满足对涉及过程本身的限制条件，如时间、费用或进行设计可用的工具。

设计的产品是一些模型，让我们能够阐明我们的结构，当需求冲突时进行折中。

软件设计方法学要素：

- 表示法。表达每个模型的语言；
- 过程。导致有序构建系统模型的过程；
- 工具。消除建模中的枯燥工作并强制实现模型本身的规则的工件，可以揭示错误和不一致性。

### 1.2. 对象模型

#### 1.2.1. 对象模型基本概念

结构化的设计方法指导开发者利用算法作为基本构建块来构建复杂系统；类似地，面向对象设计方法利用类和对象作为基本构建块，指导开发者探索基于对象和面向对象编程语言的表现力。

**【概念】面向对象编程OOP**：面向对象编程是一种实现的方法，在这种方法中，程序被组织成许多组相互协作的对象，每个对象代表某个类的一个实例，而类则属于一个通过继承关系形成的层次结构。

> 编程方法中的重点主要是正确有效地使用特定的语言机制；而设计方法的重点是正确有效地构造出复杂系统的结构。

**【概念】面向对象设计OOD**：面向对象设计是一种设计方法，包括面向对象分解的过程和一种表示法，这种表示法用于展现被设计系统的逻辑模型和物理模型、静态模型和动态模型。在OOA的模型中发明一些抽象和机制。

**【概念】面向对象分析OOA**：面向对象分析是一种分析方法，这种方法利用从问题域的词汇表中发现的类和对象来分析需求。

面向对象分析的结果可以作为开始面向对象设计的模型，面向对象设计的结果可以作为蓝图，利用面向对象编程方法最终实现一个系统。

#### 1.2.2. 对象模型要素

**编程风格**是一种组织程序的方式，基于某种编程概念模型和一种适合的语言，其目的是使得用这种风格编写的程序很清晰。对于不同的应用，应选择合适的编程风格。

5种主要的编程风格：

1. 面向过程 -- 算法
2. 面向对象 -- 类和对象
3. 面向逻辑 -- 目标，通常以谓词演算的方式表示
4. 面向规则 -- 如果-那么规则
5. 面向约束 -- 不变的关系

面向对象的概念框架的几个要素：

1. 抽象
2. 封装
3. 模块化
4. 层次结构
5. 类型
6. 并发
7. 持久

**【====抽象====】**

对于给定的问题决定一组正确的抽象，是面向对象设计的核心问题。

**抽象**描述了一个对象的基本特征，可以将这个对象与所有其他类型的对象区分开来，因此提供了清晰定义的概念边界，它与观察者的角度有关。抽象关注一个对象的外部视图，所以可以用来分离对象的基本行为和它的实现（也叫抽象壁垒）。

**最少承诺原则**：对象的接口只提供它的基本行为，此外别无其他。

**最少惊奇原则**：抽象捕捉了某个对象的全部行为，不多也不少，并且不提供抽象之外的惊奇效果或副作用。

> 从那些准确地为问题域实体建模的对象到那些实际上没有什么理由存在的对象，存在着一系列的抽象。

- **实体抽象**  - 一个对象代表了问题域或解决方案域实体的一个有用的模型。
- **动作抽象** - 一个对象提供了一组通用的操作，所有这些操作都执行同类的功能。
- **虚拟机抽象** - 一个对象几种了某种高层控制要用到的所有操作，或者这些操作将利用某种更底层的操作集。
- **偶然抽象** - 一个对象封装了一组相互间没有关系的操作

**编程契约模型**：每个对象的外部视图定义了一份契约，其他对象可以依赖这份契约，而该对象则需要它的内部视图来实现这份契约。

**客户对象**：是使用其他对象的资源的对象。可以通过考虑对象提供给其他对象的服务来总结一个对象的行为，以及它可能施加在其他对象上的操作。

**协议**：客户对象可以调用的整个操作集，以及这些操作合法的调用顺序，称为它的协议。协议表明了对象的动作和反应的方式，从而构成了抽象的完成静态和动态外部视图。

抽象思想的核心是不变性的概念。对于对象的每个操作，我们可以定义**前置条件**（操作假定的不变量）和**后置条件**（操作满足的不变量）。违反一个不变量将破坏一个抽象相关的契约。

没有对象是孤立的，每个对象都与其他对象协作，实现某种行为。这些对象之间如何协作的设计决策，定义了每种抽象的边界，从而也定义了每个对象的责任和协议。

**【====封装====】**

**封装**是一个过程，它分隔构成抽象的结构和行为的元素。通过信息隐藏来实现。作用是分离抽象的概念接口及其实现。封装在不同的抽象之间提供了明确的边界，因此导致了清晰的分离关注。

对象的抽象应该优先于它的实现决定。

**抽象**和**封装**是互补的概念：

- 抽象关注对象的可以观察到的行为，而封装关注这些行为的实现。
- 抽象帮助人们思考他们做什么，而封装让程序可以借助最少的工作进行可靠地修改。

明智的封装使可能改变的设计决策局部化。

**【====模块化====】**

> 分解为模块的整体目标是通过允许模块独立地设计和修改，从而减少软件的成本……每个模块的结都应该足够简单，这样它就能被完全理解。应该能够在不知道其他模块的实现方法，并不会影响其他模块的行为的情况下，修改某个模块的实现。修改设计的容易程度应该能够满足需要变更的可能性。

**模块化**是一个系统的属性，这个系统被分解为一组高内聚、低耦合的模块。

一个对象围绕单一的抽象提供了一个明确的边界，封装和模块化都围绕这种抽象提供了屏障。

类和对象的确定是系统逻辑设计的一部分，而模块的确定是系统物理设计的一部分。我们不能在物理设计之前完成所有逻辑设计。

影响模块化的决定的问题：

1. 开发者可能以方便复用的方式对类和对象进行打包；
2. 对单个模块的规模可能有实际的限制。（考虑局部性原理）
3. 开发者的工作分配。
4. 接口变更的影响。

**【====层次结构====】**

一组抽象常常构成一个层次结构，通过在设计中确定这些层次结构，可以极大地简化对系统的理解。

**层次结构**是抽象的一种分级或排序。

**继承**是最重要的“是一种”层次结构。

> 数据抽象试图提供一个透明的边界，在这个边界之后，方法和状态是隐藏的。继承要求将这个接口开放到一定程度，允许不通过抽象来访问状态和方法。

对于某个类来说，通常有2种客户：调用这个类的实例的方法的对象，和从这个类继承的子类。

通过继承，封装可以通过3种方式被打破：

1. 子类可能访问其超类的实例变量；
2. 可以调用其超类的私有操作；
3. 直接引用其超类的超类。

因此程序设计语言在支持封闭和继承的方面进行了折中：

类的接口可以有3个部分：

1. 私有部分（声明只能够由该类本身访问的成员）；
2. 保护部分（声明可以由该类及其子类访问的成员）；
3. 公有部分（可以被所有客户访问）

多重继承会带来2个问题：不同超类的名字冲突，重复继承。

“是一种”层次结构说明了一般/特殊关系，而“组成部分”层次结构描述了**聚合关系**。

聚合允许对逻辑结构进行物理分组，而继承允许这些共同的部分在不同的抽象中被复用。

**【====类型====】**

**类型**是关于一个对象的类的强制规定，这样一来，不同类型的对象不能够互换使用，或者至少它们的互换使用受到非常严格的限制。

类型匹配的概念是类型概念的核心。强类型使得可以利用编程语言来执行某些设计决策。

类型的强与弱指的是类型一致性，而类型的静态与动态指的是名字与类型的绑定时间。

**多态**是动态类型和继承相互作用时出现的一种情况。多态，即一个名字可以代表许多不同类的对象，这些类具有某个共同的超类，这个名字锁代表的对象因此可以响应一组共同的操作。

**【====并发====】**

**主动的**对象代表一个独立的控制线程，是一种过程抽象。

**并发**是一种属性，它区分了主动对象和非主动对象。

实现并发最重要的是如何同步对象之间的活动。

**【====持久====】**

对象持久的谱系：

- 表达式计算的瞬时结果；
- 过程执行时的局部变量；
- 自有变量、全局变量、堆中的值，它们的存在时间与它们的有效范围不同；
- 在程序执行之间存在的数据；
- 在程序的不同版本之间存在的数据；
- 比程序生命期长的数据；

编程语言和数据库技术需要同时分别关注以上不同类型的持久，以免形成奇怪的架构。

例子：面向对象的数据库，对象-关系映射框架。

**持久**是对象的一种属性，利用这种属性，对象跨越时间和空间而存在。

### 1.3. 类与对象

#### 1.3.1. 对象的本质

**对象**：一个对象是一个具有**状态**、**行为**和**标识符**的实体。结构和行为类似的对象定义在他们共同的类中。

比如：真实世界中的物理对象，事件或过程对象，物理边界不清晰的对象等。

**【====状态====】**

对象的**状态**包括这个对象的所有属性（通常是静态的）以及每个属性当前的值（通常是动态的）。

对象是有存在时间的、可以变化的、有状态的、可以实例化的、可以被创建、销毁和共享的。

状态也意味着每个对象在物理世界或计算机内存中占据一定的空间。

系统中所有的对象都封装了某种状态，系统中所有的状态都由对象所封装。

**【====行为====】**

**行为**是对象在状态改变和消息传递方面的动作和反应的方式。对象的行为代表了它外部可见的活动。

一个对象的状态代表了它的行为的累积效果。

==》**操作**

一个**操作**代表了一个类提供给它的对象的一种服务。

常见的操作包括：修改、选择、遍历、构造、析构。

==》**角色和责任**

一个对象的所有方法共同构成了它的协议。协议定义了对象允许的行为的封装，构成了这个对象完整的静态视图和动态视图。对于大多数有用的抽象来说，将这个较大的协议分成逻辑上的行为分组是有意义的，这些分组划分了对象的行为空间，表明了一个对象可以扮演的**角色**。

**责任**意味着表达对象的一种目标以及它在系统中的位置。一个对象的状态和行为共同决定了这个对象可以扮演的角色，这又实现了这种抽象的责任。

我们常常从检查对象扮演的不同角色开始分析问题。

==》**对象像自动机**

对象中存在状态，这意味着操作调用的次序很重要。每个对象就像一个微小的、独立的自动机。

基于这种类比，可以区分对象是主动的还是被动的。主动的对象不需要由其他对象操作，就能表现出一些行为。被动对象则需要显式地操作它时，才会发生状态变化。在系统中，主动对象往往是控制的中心。

**【====标识符====】**

**标识符**是一个对象的属性，它区分这个对象与其他所有对象。

大多数程序设计语言和数据库语言使用变量名称来区分临时对象，混淆了定址能力和标识符。大多数数据库系统使用标识符主键来区分持久对象，混淆了数据值和标识符。

不能够区分对象的名称和对象本身，导致了面向对象编程中的许多错误。

#### 1.3.2. 对象之间的关系

**【====链接====】**

**链接**是两个对象之间物理上或者概念上的联系。一个对象通过它与其他对象的链接，与其他对象进行协作。

作为链接的参与者，一个对象可能扮演以下三种角色之一：

1. 控制器。这个对象可以操作其他对象，但不会被其他对象操作。类似于“主动对象”。
2. 服务器。这个对象不操作其他对象，只被其他对象操作。
3. 代理。这个对象既可以操作其他对象，也可以被其他对象操作。创建代理通常是为了表示问题领域中的一个真实对象。

**【====聚合====】**

链接表明了一种端到端的关系或客户/服务提供者的关系；而聚合则表明了一种整体/部分层次结构。

#### 1.3.3. 类的本质

**类**是一组对象，它们拥有共同的结构、共同的行为和共同的语义。

一个对象就是类的一个实例。类起到的作用是在一种抽象和所有它的客户之间建立起协议。

**制定契约**：一个较大问题的不同功能通过子契约被分配给不同的设计元素，被分解成较小的问题。

类的接口提供了它的外部视图，而实现是它的内部视图。

类的接口可分为4个部分（可见性）：

1. 公有。所有客户都可以访问的声明。
2. 保护。只能由该类本身及其子类访问的声明。
3. 私有。只能由该类本身访问的声明。
4. 包。只能由同一个包中的类访问的声明。

#### 1.3.4. 类之间的关系

**【====关联====】**

关联只代表了一种语义上的依赖关系。

关联具有多重性：一对一，一对多，多对多。

**【====继承====】**

继承代表了一般/特殊关系。一个类共享了另一个类或多各类中定义的结构和行为。继承在类之间定义了“**是一种**”关系。

没有实例的类被称为抽象类。

**多态**：一个名字可能代表许多不同类的实例。利用多态，一个操作可以被层次结构中的类以不同的方式实现。

多态和延迟绑定是分不开的，出现多态时，方法和名字的绑定要在执行时确定。

例：

在C++中，开发者可以将某个操作声明为`virtual`，从而决定它是延迟绑定的，这种操作也叫虚成员函数。为了处理这种函数，C++实现使用了vtable的概念，在对象创建时（也就是对象的类被确定时），每个需要多态选择的对象都会定义一个vtable，这个表通常包含一个虚函数指针列表，其中对虚函数指向了最近的实现。这样运行时刻的查找就被省去了：对一个对象的虚成员函数的引用只是通过相应指针的一次间接引用，可以不必查找就立即调用到正确的代码。

**【====聚合====】**

聚合提供了类实例中的整体/部分关系。和对象之间的聚合关系是并存的。

聚合可以按值包容，也就是两个对象的生存周期是紧密连接在一起的；也可以按引用包容，这也被称为组合。

**【====依赖====】**

依赖关系表明，处于这种关系一端的元素以某种方式依赖于处于另一端的元素。

#### 1.3.5. 类与对象的互动

每个对象都是某个类的一个实例，每个类都有0或多个实例。对象一旦被创建，它的类就确定了，而对象在应用的生存期中会频繁地被创建和销毁。

#### 1.3.6. 创建高品质的类与对象

类和对象的设计是一个增量、迭代的过程。

抽象的品质的5个度量指标：

1. 耦合。模块与模块之间建立的关联的强度。
2. 内聚。单个类或对象内各元素的联系程度。
3. 充分性。类应该记录某个抽象足够多的特征，从而允许有意义的、有效的交互。
4. 完整性。类的接口应该包含了某个抽象的所有方向。
5. 基础性。基础项操作就是只有访问该抽象底层表现形式才能够有效地实现的操作。

类与对象的设计包含以下3个方面

**【====1. 打造接口====】**

关键问题在于如何在太多契约和太少契约之间平衡折中，有以下几个思考点：

1. 可复用性。这个行为可以在多种上下文中使用吗？
2. 复杂性。实现这个行为的难度有多大？
3. 适用性、这个行为与打算放入的类型之间的相关程度如何？
4. 实现知识。这个行为的实现依赖于一个类型的内部细节吗？

当确定存在某个接口及其功能语言之后，还要决定它的时间语义和空间语义。这意味着必须决定它完成操作需要的时间以及存储空间。还要考虑是否涉及消息传递，也就是多线程同步场景。

**【====2. 确定关系====】**

一个抽象能否访问（看到并引用其外部视图中的资源）另一种抽象。耦合是度量可访问程度的指标。

**Demeter法则**：类的方法不应该以任何方式依赖于任何类的结构，除了它自己类的当前（顶层）结构之外。而且，每个方法只能够对一个非常有限的类集的对象发出消息。

决定对象之间的关系主要是设计这些对象进行交互的机制：这些知识应该放在哪里？谁对谁可见？

**【====3. 选择实现====】**

这一步是设计内部视图，涉及2个重要的决定：

1. 为类或对象选择表示形式，也就是具体怎么实现。
2. 将类或对象放入一个模块，应该在哪里声明类和对象。

#### 1.3.7. 类与对象在分析和设计中的角色

在分析阶段和设计的早期阶段，开发者有2个主要的任务：

1. 从问题域的词汇表中确定出类；也就是确定问题的关键抽象。
2. 创建一些结构，让多组对象一起工作，提供满足问题需求的行为。

### 1.4. 分类

#### 1.4.1. 正确分类

当进行分类时，我们寻找具有共同结构或表现出共同行为的一组事物。这个过程既涉及发现（从问题域的词汇表中识别出关键抽象和机制），也涉及发明（设计泛化的抽象和一些新的机制）。

分类高度取决于进行分类的原因，也取决于观察者的视角。

#### 1.4.2. 确定类和对象

**【====经典与现代方法====】**

1. 经典分类。“所有具有某一个或某一组共同属性的实体构成了一个分类。这样的属性对于定义这个分类是必要和充分的。”在特定情况下考虑哪些属性，这与领域是高度相关的。
2. 概念聚集。“类的产生首先是形成类的概念描述，然后再根据这些描述对实体进行分类。”
3. 原型理论。“对象的类是由一个原型对象来代表的，如果一个对象与这个原型表现出重要的相似性，那么这个对象就被认为是这个类中的一员。”

**【====面向对象分析====】**

场景是强大的面向对象分析工具，可以用于经典分析、行为分析、领域分析和用例分析

#### 1.4.3. 关键抽象与机制

关键抽象反映了问题域的词汇表，可以从问题域中发现，也可以作为设计的一部分而发明。

机制代表了战略上的设计决策，考虑的是许多不同类型的对象的协作活动。

## 2. 方法

介绍了一种共同而标准的语言——统一建模语言UML

### 2.1. 表示法

统一建模语言UML是分析、说明和涉及软件系统的主要建模语言。UML有几种不同类型的图，每一种都提供了系统的某一种视图。

UML图主要分为2大类：**结构图**和**行为图**。（系统的复杂性既来自于系统中元素的数量和组织，即结构；也来自于这些元素协作完成其功能的方式，即行为）

**【结构图】**用于展示系统中元素的静态结构。它们描述系统的架构组织、物理元素、系统的运行时刻配置和业务中领域相关的元素等。UML结构图包括：

- 包图。
- 类图。
- 组件图。
- 部署图。
- 对象图。
- 组合结构图。

**【行为图】**描述问题的动态行为语义或它的实现。包括：

- 用例图
- 活动图
- 状态机图
- 交互图
  - 序列图
  - 通信图
  - 交互概述图
  - 时间图

在实践过程中只需要使用那些表达意思所必须的表示法元素即可，不需要过度定义。

**【====系统视图分类====】**

随着系统开发的推进和成熟，系统模式可能代表了不同的细节层次。

**概念模型**记录了系统中存在或将存在的领域实体，以及它们与系统中其他领域实体的关系。概念层的建模是利用业务领域的术语来完成的，应该是技术无关的。

**逻辑视图**利用了概念模型中创建的概念，建立起关键抽象和机制的意义，并确定系统的架构和整体设计。

**物理视图**描述了系统实现的具体软件和硬件构成。是技术相关的。

### 2.2. 包图

包图提供了表现UML元素分组的能力，主要集中在可视模型本身的物理结构上，或者通过多重视图来清晰地展现模型元素。

包图主要的元素：

- 包表示法；
- 元素可见性；
- 依赖关系。

用包分组的元素通常应该在某种意义上是相关的。好的分包是松耦合、高内聚的。

**====【包表示法】====**

黑盒视图，包含视图；

也可以用于展示许多不同建模元素的结构和包容关系。比如包、类、用例等。

**====【元素可见性】====**

可见性是从包容的包的角度定义的，包为它包含的元素提供了命名空间。每个被包容的元素具有唯一的名称。元素可以是公有的（+）或者私有的（-）。公有的元素被认为是这个包接口的一部分。

**====【依赖关系】====**

依赖关系显示了一个元素依赖于另一个元素来实现它在系统中的责任。

依赖关系用一个虚线的开放箭头`---->`表示，箭头尾部位于具有依赖性的元素（客户），箭头位于支持这种依赖的元素（提供者）。依赖关系可以标上标签，用`<<relation>>`表示依赖关系的类型。

包特有的依赖关系包括：导入，访问，合并。

由于包容元素之间的关系导致包间依赖关系包括：跟踪，派生，精化，允许，使用。

**==》导入和访问**

**导入**是一种公有的包导入（`<<import>>`），访问是一种私有的包导入（`<<access>>`）。包的导入和访问可以让我们通过限定名称引用其他命名空间的公有元素。

无限定名称是没有任何路径信息的名称。在包中，可以使用无限定名称访问以下元素：

- 包拥有的元素；
- 导入的元素；
- 外层包中的元素。

但是外层包必须要导入它内嵌的包才可以使用无限定的名称来引用它们的元素。

### 2.3. 组件图

组件代表了一块可复用的软件，是一种结构化的分类器，组件间的协作和内部结构可以利用组件图来表示。我们可以用组件分层地解构一个系统，并表示它的逻辑架构。

组件图的基本元素是**组件**，**它们的接口**和**它们的实现**。

**====【组件表示法】====**

一个组件的结构包括**部件**、**端口**和**连接器**。

端口具有公有可见性，用小正方形表示。组件通过端口与它的环境交互，端口为这个结构化的分类器提供了封装。

端口有与之相连的接口，定义了组件交互的细节。用小球表示的接口表明组件向环境提供的功能；用球窝表示的接口表明组件向环境要求的接口。

端口可以对接口进行分组，所以不一定是一对一的关系。

**====【组件图】====**

组件图可以表达架构的逻辑分层和划分方式，展现了组件间的相互依赖关系，也就是它们通过定义良好的接口进行协作。

一个组件只要实现了另一个组件要求的接口，它就可以替代另一个组件，从而实现组件的复用。

组件还可以通过内部结构图来标识其内部结构。使用子系统划分系统的逻辑模型，系统中的每个组件要么处于某个子系统中，要么处于系统的顶层。

**====【组件接口】====**

接口规格说明可以更详细地显示组件的接口。

`<<realize>>`或`<<provided interfaces>>`表示组件提供的接口；

`<<use>>`或`<<required interfaces>>`表示组件要求的接口。

**====【组件实现】====**

组件和类之间的关系可以表示组件对接口的实现和要求。

### 2.4. 部署图

部署图用于展示在系统的物理设计中，工件在节点上分布的情况。我们使用部署图来说明节点的物理集合，这些节点是系统执行的平台。

部署图的基本元素是**工件**、**节点**和它们的**连接**。

**====【工件】====**

工件是物理上存在的一些东西，它实现了一部分的软件设计。可以使软件代码（可执行），也可以是一个源文件、文档或与代码相关的其他文件。

工件可以和组件建立关系，这样实现和设计就联系起来了。

**====【节点】====**

节点是一种计算资源，通常包含存储和处理能力，工件部署在它上面运行。

有2种类型的节点：**设备**和**执行环境**。

- 设备是一个提供了计算能力的硬件，如一台计算机、一个调制解调器或传感器。
- 执行环境是软件，用于部署特定类型的执行工件。执行环境通常以一个设备作为宿主。

### 2.5. 用例图

### 2.6. 活动图

### 2.7. 类图

### 2.8. 序列图

### 2.9. 交互概述图

### 2.10. 组合结构图

### 2.11. 状态机图

### 2.12. 时间图

### 2.13. 对象图

### 2.14. 通信图

## 3. 过程

## 4. 实践

## 5. 应用
